package main

import "fmt"

/*
动态规划通常涉及以下几个步骤：

定义子问题：找到一个递推关系，将大问题分解为小问题。
实现递推关系：使用一个数组或者其他数据结构来存储子问题的解。
初始化边界条件：确定递推关系的起始值。
填表：根据递推关系，计算出所有子问题的解。
返回最终解：通常是最后一个小问题的解。
在爬楼梯问题中，我们可以这样定义递推关系：

到达第n阶的方法数 = 到达第n-1阶的方法数 + 到达第n-2阶的方法数。
这是因为，要到达第n阶，你可以从第n-1阶爬1阶上来，或者从第n-2阶爬2阶上来。所以，到达第n阶的方法数就是到达第n-1阶和第n-2阶方法数的总和。


*/

// 使用动态规划解决爬楼梯问题
func climbStairs(n int) int {
	if n <= 2 {
		return n // 如果楼梯少于等于2阶，直接返回楼梯阶数
	}
	dp := make([]int, n+1) // 创建一个长度为n+1的数组，用于存储到达每一阶的方法数
	dp[1], dp[2] = 1, 2    // 初始化前两阶的方法数

	// 从第3阶开始，计算到达每一阶的方法数
	for i := 3; i <= n; i++ {
		dp[i] = dp[i-1] + dp[i-2] // 根据递推关系填表
	}

	return dp[n] // 返回到达第n阶的方法数
}

func main() {
	n := 10 // 假设要爬10阶楼梯
	ways := climbStairs(n)
	fmt.Printf("There are %d ways to climb %d stairs.\n", ways, n)
}
